<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Detection Real-Time | TensorFlow.js COCO-SSD</title>
  
  <!-- TensorFlow.js & COCO-SSD Model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 400% 400%;
      animation: gradientAnimation 15s ease infinite;
      min-height: 100vh;
      padding: 20px;
      color: white;
    }
    
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      animation: fadeIn 0.8s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Header Section */
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 30px 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }
    
    .header h1 {
      font-size: 2.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-shadow: 0 4px 20px rgba(255, 255, 255, 0.3);
      animation: glow 2s ease-in-out infinite alternate;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5)); }
      to { filter: drop-shadow(0 0 25px rgba(255, 255, 255, 0.8)); }
    }
    
    .header p {
      font-size: 1.1rem;
      opacity: 0.95;
      font-weight: 300;
    }
    
    /* Status Bar */
    .status-bar {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(15px);
      border-radius: 15px;
      padding: 20px 30px;
      margin-bottom: 25px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
    }
    
    .status-bar.loading {
      background: rgba(251, 191, 36, 0.2);
      border-color: rgba(251, 191, 36, 0.5);
    }
    
    .status-bar.ready {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.5);
    }
    
    .status-bar.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.5);
    }
    
    .status-bar strong {
      font-size: 1.1rem;
      display: block;
      margin-bottom: 5px;
    }
    
    /* Control Panel */
    .control-panel {
      display: flex;
      gap: 15px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    
    .btn {
      padding: 15px 30px;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }
    
    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    }
    
    .btn:active {
      transform: translateY(-1px);
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn:active::before {
      width: 300px;
      height: 300px;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Stats Display */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(15px);
      border-radius: 15px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
    }
    
    .stat-card .label {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: #fff;
    }
    
    /* Main Content Area */
    .content-wrapper {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 25px;
    }
    
    @media (max-width: 1024px) {
      .content-wrapper {
        grid-template-columns: 1fr;
      }
    }
    
    /* Video Container */
    .video-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 20px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.2);
      transition: all 0.4s ease;
    }
    
    .video-container:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    
    #webcam, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    #canvas {
      pointer-events: none;
    }
    
    .placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    
    .placeholder-icon {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.7;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); opacity: 1; }
    }
    
    .placeholder p {
      font-size: 1.1rem;
      margin-bottom: 10px;
    }
    
    .placeholder small {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    
    /* Detection Log Panel */
    .log-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(15px);
      border-radius: 20px;
      padding: 25px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      max-height: 600px;
      overflow-y: auto;
    }
    
    .log-panel h3 {
      font-size: 1.3rem;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .log-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 12px;
      border-left: 4px solid #667eea;
      transition: all 0.3s ease;
    }
    
    .log-item:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateX(5px);
    }
    
    .log-item .object-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .log-item .confidence {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .log-item .timestamp {
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 5px;
    }
    
    /* Scrollbar Styling */
    .log-panel::-webkit-scrollbar {
      width: 8px;
    }
    
    .log-panel::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }
    
    .log-panel::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 10px;
    }
    
    .log-panel::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* Footer */
    .footer {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(15px);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      opacity: 0.9;
    }
    
    .footer p {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }
    
    /* Threshold Control */
    .threshold-control {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(15px);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 25px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .threshold-control label {
      font-weight: 500;
    }
    
    .threshold-control input[type="range"] {
      flex: 1;
      min-width: 200px;
      height: 6px;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
      -webkit-appearance: none;
    }
    
    .threshold-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .threshold-control input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .threshold-value {
      font-size: 1.2rem;
      font-weight: 700;
      min-width: 60px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üéØ Object Detection Real-Time</h1>
      <p>Powered by TensorFlow.js & COCO-SSD Model</p>
    </div>
    
    <!-- Status Bar -->
    <div id="statusBar" class="status-bar loading">
      <strong id="statusTitle">‚è≥ Memuat Model...</strong>
      <div id="statusMessage">Sedang mengunduh model COCO-SSD. Mohon tunggu sebentar.</div>
    </div>
    
    <!-- Control Panel -->
    <div class="control-panel">
      <button id="btnStart" class="btn btn-primary" disabled>‚ñ∂ Mulai Deteksi</button>
      <button id="btnStop" class="btn btn-secondary" disabled>‚è∏ Hentikan</button>
      <button id="btnSwitch" class="btn btn-primary" disabled>üîÑ Ganti Kamera</button>
      <button id="btnClearLog" class="btn btn-secondary">üóë Bersihkan Log</button>
    </div>
    
    <!-- Threshold Control -->
    <div class="threshold-control">
      <label for="thresholdSlider">Confidence Threshold:</label>
      <input type="range" id="thresholdSlider" min="0" max="100" value="50" step="5">
      <span class="threshold-value"><span id="thresholdValue">50</span>%</span>
    </div>
    
    <!-- Stats Display -->
    <div class="stats">
      <div class="stat-card">
        <div class="label">FPS</div>
        <div class="value" id="fpsValue">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Objek Terdeteksi</div>
        <div class="value" id="objectCount">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Total Deteksi</div>
        <div class="value" id="totalDetections">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Warna Dominan</div>
        <div class="value" id="dominantColor" style="font-size: 1rem;">‚Äî</div>
      </div>
      <div class="stat-card">
        <div class="label">Estimasi Jarak</div>
        <div class="value" id="distanceValue" style="font-size: 1.3rem;">‚Äî</div>
      </div>
    </div>
    
    <!-- Main Content -->
    <div class="content-wrapper">
      <!-- Video Container -->
      <div class="video-container">
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="placeholder" class="placeholder">
          <svg class="placeholder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
          <p>Kamera akan aktif setelah Anda klik "Mulai Deteksi"</p>
          <small>Pastikan izin akses kamera telah diaktifkan</small>
        </div>
      </div>
      
      <!-- Detection Log Panel -->
      <div class="log-panel">
        <h3>üìã Log Deteksi</h3>
        <div id="logContainer">
          <div style="opacity: 0.6; text-align: center; padding: 20px;">
            Belum ada objek yang terdeteksi
          </div>
        </div>
      </div>
    </div>
    
    <!-- Footer -->
    <div class="footer">
      <p><strong>100% Berjalan di Browser</strong></p>
      <p>Tidak ada data yang dikirim ke server. Semua proses dilakukan secara lokal di perangkat Anda.</p>
      <p style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">Model: COCO-SSD | Framework: TensorFlow.js</p>
    </div>
  </div>

  <script>
    // ============================================
    // COLOR DETECTION FUNCTIONS
    // ============================================
    function detectDominantColor(predictions) {
      if (predictions.length === 0) {
        dominantColorEl.innerHTML = '‚Äî';
        dominantColorEl.style.background = 'transparent';
        return null;
      }
      
      // Get the largest object for color detection
      const largestObject = predictions.reduce((prev, current) => {
        const prevArea = prev.bbox[2] * prev.bbox[3];
        const currentArea = current.bbox[2] * current.bbox[3];
        return currentArea > prevArea ? current : prev;
      });
      
      const [x, y, width, height] = largestObject.bbox;
      
      // Create temporary canvas untuk sampling dari video langsung
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = width;
      tempCanvas.height = height;
      
      // Draw dari video, bukan dari canvas yang sudah ada drawing
      tempCtx.drawImage(webcam, x, y, width, height, 0, 0, width, height);
      
      // Sample pixels from center area (avoid edges)
      const margin = Math.min(width, height) * 0.1; // 10% margin dari tepi
      const sampleX = Math.floor(margin);
      const sampleY = Math.floor(margin);
      const sampleWidth = Math.floor(width - margin * 2);
      const sampleHeight = Math.floor(height - margin * 2);
      
      const imageData = tempCtx.getImageData(sampleX, sampleY, sampleWidth, sampleHeight);
      const pixels = imageData.data;
      
      // Gunakan histogram untuk color quantization yang lebih akurat
      const colorBuckets = {};
      
      // Sample setiap 16 pixel (lebih banyak sample untuk akurasi)
      for (let i = 0; i < pixels.length; i += 16) {
        const r = Math.floor(pixels[i] / 32) * 32; // Quantize ke 32-step
        const g = Math.floor(pixels[i + 1] / 32) * 32;
        const b = Math.floor(pixels[i + 2] / 32) * 32;
        const alpha = pixels[i + 3];
        
        // Skip transparent pixels
        if (alpha < 128) continue;
        
        const key = `${r},${g},${b}`;
        colorBuckets[key] = (colorBuckets[key] || 0) + 1;
      }
      
      // Find most frequent color
      let maxCount = 0;
      let dominantRGB = [0, 0, 0];
      
      for (const [key, count] of Object.entries(colorBuckets)) {
        if (count > maxCount) {
          maxCount = count;
          dominantRGB = key.split(',').map(Number);
        }
      }
      
      const [r, g, b] = dominantRGB;
      
      // Get color name dengan algoritma HSV yang lebih akurat
      const colorName = getColorName(r, g, b);
      const rgbColor = `rgb(${r}, ${g}, ${b})`;
      
      // Update display
      dominantColorEl.innerHTML = `<span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: ${rgbColor}; margin-right: 8px; border: 2px solid white; vertical-align: middle; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></span>${colorName}`;
      
      return { r, g, b, name: colorName, rgb: rgbColor };
    }
    
    function getColorName(r, g, b) {
      // Convert RGB to HSV untuk deteksi warna yang lebih akurat
      const rNorm = r / 255;
      const gNorm = g / 255;
      const bNorm = b / 255;
      
      const max = Math.max(rNorm, gNorm, bNorm);
      const min = Math.min(rNorm, gNorm, bNorm);
      const diff = max - min;
      
      // Calculate HSV
      let h = 0;
      const s = max === 0 ? 0 : diff / max;
      const v = max;
      
      if (diff !== 0) {
        if (max === rNorm) {
          h = 60 * (((gNorm - bNorm) / diff) % 6);
        } else if (max === gNorm) {
          h = 60 * (((bNorm - rNorm) / diff) + 2);
        } else {
          h = 60 * (((rNorm - gNorm) / diff) + 4);
        }
      }
      
      if (h < 0) h += 360;
      
      // Deteksi warna berdasarkan HSV
      // Cek achromatic (hitam, putih, abu-abu)
      if (s < 0.15) {
        if (v < 0.2) return 'Hitam';
        if (v < 0.35) return 'Abu Gelap';
        if (v < 0.65) return 'Abu-abu';
        if (v < 0.85) return 'Abu Terang';
        return 'Putih';
      }
      
      // Deteksi warna berdasarkan Hue dengan threshold lebih presisi
      if (v < 0.25) return 'Hitam'; // Warna gelap sekali
      
      // Merah: 0-15 dan 345-360
      if (h < 15 || h >= 345) {
        if (s > 0.6 && v > 0.5) return 'Merah';
        return 'Merah Muda';
      }
      
      // Oranye: 15-45
      if (h >= 15 && h < 45) {
        if (v > 0.6) return 'Oranye';
        return 'Coklat';
      }
      
      // Kuning: 45-70
      if (h >= 45 && h < 70) {
        if (s > 0.5 && v > 0.6) return 'Kuning';
        if (v < 0.5) return 'Coklat Muda';
        return 'Krem';
      }
      
      // Hijau Kuning: 70-80
      if (h >= 70 && h < 80) {
        return 'Hijau Kuning';
      }
      
      // Hijau: 80-150
      if (h >= 80 && h < 150) {
        if (s > 0.5 && v > 0.5) return 'Hijau';
        if (v > 0.6) return 'Hijau Terang';
        return 'Hijau Gelap';
      }
      
      // Cyan/Tosca: 150-190
      if (h >= 150 && h < 190) {
        if (v > 0.6) return 'Cyan';
        return 'Tosca';
      }
      
      // Biru: 190-250
      if (h >= 190 && h < 250) {
        if (s > 0.6 && v > 0.5) return 'Biru';
        if (v > 0.6) return 'Biru Muda';
        return 'Biru Tua';
      }
      
      // Ungu/Violet: 250-290
      if (h >= 250 && h < 290) {
        if (s > 0.5) return 'Ungu';
        return 'Lavender';
      }
      
      // Magenta/Pink: 290-345
      if (h >= 290 && h < 345) {
        if (s > 0.6 && v > 0.5) return 'Magenta';
        if (v > 0.6) return 'Pink';
        return 'Ungu Tua';
      }
      
      return 'Warna Campuran';
    }
    
    // ============================================
    // DISTANCE ESTIMATION FUNCTIONS
    // ============================================
    
    // Database ukuran rata-rata objek dalam dunia nyata (dalam cm)
    const OBJECT_REAL_SIZES = {
      'person': 170,        // tinggi rata-rata manusia
      'car': 450,           // panjang mobil
      'motorcycle': 200,    // panjang motor
      'bicycle': 180,       // panjang sepeda
      'bus': 1200,          // panjang bus
      'truck': 800,         // panjang truk
      'bottle': 25,         // tinggi botol
      'cup': 10,            // tinggi gelas
      'chair': 90,          // tinggi kursi
      'couch': 200,         // panjang sofa
      'dining table': 180,  // panjang meja makan
      'laptop': 35,         // lebar laptop
      'keyboard': 45,       // panjang keyboard
      'mouse': 10,          // panjang mouse
      'cell phone': 15,     // tinggi HP
      'book': 23,           // tinggi buku
      'clock': 30,          // diameter jam dinding
      'tv': 120,            // lebar TV
      'potted plant': 40,   // tinggi pot tanaman
      'vase': 30,           // tinggi vas
      'backpack': 45,       // tinggi ransel
      'handbag': 35,        // tinggi tas
      'suitcase': 70,       // tinggi koper
      'dog': 60,            // tinggi anjing
      'cat': 25,            // tinggi kucing
      'bird': 15,           // tinggi burung
      'apple': 8,           // diameter apel
      'orange': 8,          // diameter jeruk
      'banana': 20,         // panjang pisang
      'scissors': 20,       // panjang gunting
      'teddy bear': 40,     // tinggi boneka teddy
      'tennis racket': 68,  // panjang raket tenis
      'sports ball': 22,    // diameter bola
    };
    
    // Focal length estimasi (dalam pixel) - akan di-kalibrasi otomatis
    let FOCAL_LENGTH = 600; // default, akan disesuaikan
    
    function estimateDistance(predictions) {
      if (predictions.length === 0) {
        distanceValueEl.innerHTML = '‚Äî';
        return null;
      }
      
      // Ambil objek terbesar
      const largestObject = predictions.reduce((prev, current) => {
        const prevArea = prev.bbox[2] * prev.bbox[3];
        const currentArea = current.bbox[2] * current.bbox[3];
        return currentArea > prevArea ? current : prev;
      });
      
      const objectClass = largestObject.class;
      const [x, y, width, height] = largestObject.bbox;
      
      // Cek apakah objek ini ada di database
      if (!OBJECT_REAL_SIZES[objectClass]) {
        distanceValueEl.innerHTML = '<span style="font-size: 0.9rem;">Tidak tersedia</span>';
        return null;
      }
      
      const realSize = OBJECT_REAL_SIZES[objectClass]; // dalam cm
      
      // Gunakan dimensi yang lebih besar (width atau height)
      const pixelSize = Math.max(width, height);
      
      // Auto-kalibrasi focal length berdasarkan resolusi video
      const videoWidth = canvas.width;
      FOCAL_LENGTH = videoWidth * 0.7; // estimasi focal length
      
      // Formula: Distance = (Real_Size √ó Focal_Length) / Pixel_Size
      const distanceCm = (realSize * FOCAL_LENGTH) / pixelSize;
      const distanceM = distanceCm / 100;
      
      // Format output berdasarkan jarak
      let displayText;
      let distanceClass;
      
      if (distanceM < 0.5) {
        displayText = `${distanceCm.toFixed(0)} cm`;
        distanceClass = 'Sangat Dekat';
      } else if (distanceM < 2) {
        displayText = `${distanceM.toFixed(2)} m`;
        distanceClass = 'Dekat';
      } else if (distanceM < 5) {
        displayText = `${distanceM.toFixed(1)} m`;
        distanceClass = 'Sedang';
      } else if (distanceM < 10) {
        displayText = `${distanceM.toFixed(1)} m`;
        distanceClass = 'Jauh';
      } else {
        displayText = `${distanceM.toFixed(0)} m`;
        distanceClass = 'Sangat Jauh';
      }
      
      // Update display dengan icon
      const icon = getDistanceIcon(distanceM);
      distanceValueEl.innerHTML = `${icon} ${displayText}<br><span style="font-size: 0.7rem; opacity: 0.8;">${distanceClass}</span>`;
      
      return {
        distanceCm,
        distanceM,
        distanceClass,
        displayText,
        objectClass
      };
    }
    
    function getDistanceIcon(distanceM) {
      if (distanceM < 0.5) return 'üî¥';      // Sangat dekat
      if (distanceM < 2) return 'üü†';        // Dekat
      if (distanceM < 5) return 'üü°';        // Sedang
      if (distanceM < 10) return 'üü¢';       // Jauh
      return 'üîµ';                            // Sangat jauh
    }
    
    // ============================================
    // CONFIGURATION & GLOBAL VARIABLES
    // ============================================
    let model = null;
    let webcam = null;
    let canvas = null;
    let ctx = null;
    let stream = null;
    let isDetecting = false;
    let animationId = null;
    let facingMode = 'environment'; // 'user' or 'environment'
    let threshold = 0.5;
    let totalDetections = 0;
    
    // FPS Calculation
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let fps = 0;
    
    // Detection Log
    const detectionLog = [];
    const MAX_LOG_ITEMS = 50;
    
    // ============================================
    // DOM ELEMENTS
    // ============================================
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnSwitch = document.getElementById('btnSwitch');
    const btnClearLog = document.getElementById('btnClearLog');
    const statusBar = document.getElementById('statusBar');
    const statusTitle = document.getElementById('statusTitle');
    const statusMessage = document.getElementById('statusMessage');
    const placeholder = document.getElementById('placeholder');
    const fpsValue = document.getElementById('fpsValue');
    const objectCount = document.getElementById('objectCount');
    const totalDetectionsEl = document.getElementById('totalDetections');
    const dominantColorEl = document.getElementById('dominantColor');
    const distanceValueEl = document.getElementById('distanceValue');
    const logContainer = document.getElementById('logContainer');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdValue = document.getElementById('thresholdValue');
    
    // ============================================
    // INITIALIZATION
    // ============================================
    async function init() {
      webcam = document.getElementById('webcam');
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');
      
      updateStatus('loading', '‚è≥ Memuat Model...', 'Sedang mengunduh model COCO-SSD. Mohon tunggu sebentar.');
      
      try {
        // Load COCO-SSD model
        model = await cocoSsd.load();
        
        updateStatus('ready', '‚úÖ Model Siap!', 'Klik "Mulai Deteksi" untuk memulai.');
        btnStart.disabled = false;
        
      } catch (error) {
        console.error('Error loading model:', error);
        updateStatus('error', '‚ùå Error!', `Gagal memuat model: ${error.message}`);
      }
    }
    
    // ============================================
    // CAMERA CONTROLS
    // ============================================
    async function startCamera() {
      try {
        // Stop existing stream
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
        
        const constraints = {
          video: {
            facingMode: facingMode,
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };
        
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        webcam.srcObject = stream;
        
        // Wait for video to load
        await new Promise((resolve) => {
          webcam.onloadedmetadata = () => {
            webcam.play();
            resolve();
          };
        });
        
        // Set canvas size
        canvas.width = webcam.videoWidth;
        canvas.height = webcam.videoHeight;
        
        placeholder.style.display = 'none';
        
        return true;
      } catch (error) {
        console.error('Error accessing camera:', error);
        updateStatus('error', '‚ùå Error Kamera', `Gagal mengakses kamera: ${error.message}`);
        return false;
      }
    }
    
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
        webcam.srcObject = null;
      }
      placeholder.style.display = 'flex';
    }
    
    // ============================================
    // OBJECT DETECTION
    // ============================================
    async function detectObjects() {
      if (!isDetecting || !model || webcam.readyState !== 4) {
        if (isDetecting) {
          animationId = requestAnimationFrame(detectObjects);
        }
        return;
      }
      
      try {
        // Run detection
        const predictions = await model.detect(webcam);
        
        // Filter by threshold
        const filteredPredictions = predictions.filter(pred => pred.score >= threshold);
        
        // Draw results
        drawPredictions(filteredPredictions);
        
        // Detect dominant color
        const colorInfo = detectDominantColor(filteredPredictions);
        
        // Estimate distance
        const distanceInfo = estimateDistance(filteredPredictions);
        
        // Update stats
        updateStats(filteredPredictions);
        
        // Log detections with color and distance
        logDetections(filteredPredictions, colorInfo, distanceInfo);
        
        // Calculate FPS
        calculateFPS();
        
      } catch (error) {
        console.error('Detection error:', error);
      }
      
      // Continue detection loop
      animationId = requestAnimationFrame(detectObjects);
    }
    
    // ============================================
    // DRAWING FUNCTIONS
    // ============================================
    function drawPredictions(predictions) {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set drawing style
      ctx.lineWidth = 3;
      ctx.font = 'bold 18px Poppins, sans-serif';
      ctx.textBaseline = 'top';
      
      predictions.forEach(prediction => {
        const [x, y, width, height] = prediction.bbox;
        
        // Draw bounding box with gradient
        const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#764ba2');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 4;
        
        // Draw rounded rectangle
        drawRoundedRect(ctx, x, y, width, height, 10);
        ctx.stroke();
        
        // Prepare label dengan estimasi jarak
        const label = `${prediction.class}`;
        const confidence = `${(prediction.score * 100).toFixed(1)}%`;
        
        // Estimasi jarak untuk objek ini
        let distanceText = '';
        if (OBJECT_REAL_SIZES[prediction.class]) {
          const realSize = OBJECT_REAL_SIZES[prediction.class];
          const pixelSize = Math.max(width, height);
          const distanceCm = (realSize * FOCAL_LENGTH) / pixelSize;
          const distanceM = distanceCm / 100;
          
          if (distanceM < 1) {
            distanceText = ` ‚Ä¢ ${distanceCm.toFixed(0)}cm`;
          } else {
            distanceText = ` ‚Ä¢ ${distanceM.toFixed(1)}m`;
          }
        }
        
        const text = `${label} ${confidence}${distanceText}`;
        
        // Measure text
        const textMetrics = ctx.measureText(text);
        const textWidth = textMetrics.width;
        const textHeight = 24;
        const padding = 8;
        
        // Draw label background
        ctx.fillStyle = 'rgba(102, 126, 234, 0.9)';
        drawRoundedRectFill(ctx, x, y - textHeight - padding, textWidth + padding * 2, textHeight + padding, 8);
        
        // Draw text
        ctx.fillStyle = '#ffffff';
        ctx.fillText(text, x + padding, y - textHeight - padding / 2);
        
        // Draw corner accents
        drawCornerAccents(ctx, x, y, width, height);
      });
    }
    
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    
    function drawRoundedRectFill(ctx, x, y, width, height, radius) {
      drawRoundedRect(ctx, x, y, width, height, radius);
      ctx.fill();
    }
    
    function drawCornerAccents(ctx, x, y, width, height) {
      const accentLength = 20;
      const accentWidth = 3;
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = accentWidth;
      ctx.lineCap = 'round';
      
      // Top-left
      ctx.beginPath();
      ctx.moveTo(x, y + accentLength);
      ctx.lineTo(x, y);
      ctx.lineTo(x + accentLength, y);
      ctx.stroke();
      
      // Top-right
      ctx.beginPath();
      ctx.moveTo(x + width - accentLength, y);
      ctx.lineTo(x + width, y);
      ctx.lineTo(x + width, y + accentLength);
      ctx.stroke();
      
      // Bottom-left
      ctx.beginPath();
      ctx.moveTo(x, y + height - accentLength);
      ctx.lineTo(x, y + height);
      ctx.lineTo(x + accentLength, y + height);
      ctx.stroke();
      
      // Bottom-right
      ctx.beginPath();
      ctx.moveTo(x + width - accentLength, y + height);
      ctx.lineTo(x + width, y + height);
      ctx.lineTo(x + width, y + height - accentLength);
      ctx.stroke();
    }
    
    // ============================================
    // STATS & LOGGING
    // ============================================
    function updateStats(predictions) {
      objectCount.textContent = predictions.length;
      fpsValue.textContent = fps;
    }
    
    function calculateFPS() {
      frameCount++;
      const currentTime = performance.now();
      const elapsed = currentTime - lastFrameTime;
      
      if (elapsed >= 1000) {
        fps = Math.round((frameCount * 1000) / elapsed);
        frameCount = 0;
        lastFrameTime = currentTime;
      }
    }
    
    function logDetections(predictions, colorInfo, distanceInfo) {
      if (predictions.length === 0) return;
      
      predictions.forEach(pred => {
        totalDetections++;
        totalDetectionsEl.textContent = totalDetections;
        
        const logItem = {
          class: pred.class,
          score: pred.score,
          timestamp: new Date().toLocaleTimeString('id-ID'),
          color: colorInfo ? colorInfo.name : '‚Äî',
          rgb: colorInfo ? colorInfo.rgb : null,
          distance: distanceInfo ? distanceInfo.displayText : '‚Äî',
          distanceClass: distanceInfo ? distanceInfo.distanceClass : null
        };
        
        detectionLog.unshift(logItem);
        
        // Limit log size
        if (detectionLog.length > MAX_LOG_ITEMS) {
          detectionLog.pop();
        }
      });
      
      updateLogDisplay();
    }
    
    function updateLogDisplay() {
      if (detectionLog.length === 0) {
        logContainer.innerHTML = '<div style="opacity: 0.6; text-align: center; padding: 20px;">Belum ada objek yang terdeteksi</div>';
        return;
      }
      
      logContainer.innerHTML = detectionLog.map(item => `
        <div class="log-item">
          <div class="object-name">${item.class}</div>
          <div class="confidence">Confidence: ${(item.score * 100).toFixed(1)}%</div>
          ${item.color ? `<div class="confidence">
            <span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background: ${item.rgb}; margin-right: 5px; border: 1px solid rgba(255,255,255,0.3); vertical-align: middle;"></span>
            Warna: ${item.color}
          </div>` : ''}
          ${item.distance ? `<div class="confidence">üìè Jarak: ${item.distance} <span style="opacity: 0.7;">(${item.distanceClass})</span></div>` : ''}
          <div class="timestamp">${item.timestamp}</div>
        </div>
      `).join('');
    }
    
    function clearLog() {
      detectionLog.length = 0;
      totalDetections = 0;
      totalDetectionsEl.textContent = '0';
      updateLogDisplay();
    }
    
    // ============================================
    // UI FUNCTIONS
    // ============================================
    function updateStatus(type, title, message) {
      statusBar.className = `status-bar ${type}`;
      statusTitle.textContent = title;
      statusMessage.textContent = message;
    }
    
    // ============================================
    // EVENT HANDLERS
    // ============================================
    btnStart.addEventListener('click', async () => {
      btnStart.disabled = true;
      updateStatus('loading', '‚è≥ Memulai Kamera...', 'Mohon izinkan akses kamera.');
      
      const success = await startCamera();
      
      if (success) {
        isDetecting = true;
        detectObjects();
        
        updateStatus('ready', '‚úÖ Deteksi Aktif!', 'Sistem sedang mendeteksi objek secara real-time.');
        btnStart.disabled = true;
        btnStop.disabled = false;
        btnSwitch.disabled = false;
      } else {
        btnStart.disabled = false;
      }
    });
    
    btnStop.addEventListener('click', () => {
      isDetecting = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      stopCamera();
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      updateStatus('ready', '‚è∏ Deteksi Dihentikan', 'Klik "Mulai Deteksi" untuk melanjutkan.');
      btnStart.disabled = false;
      btnStop.disabled = true;
      btnSwitch.disabled = true;
      
      // Reset stats
      fpsValue.textContent = '0';
      objectCount.textContent = '0';
    });
    
    btnSwitch.addEventListener('click', async () => {
      facingMode = facingMode === 'environment' ? 'user' : 'environment';
      
      updateStatus('loading', 'üîÑ Mengganti Kamera...', 'Tunggu sebentar...');
      btnSwitch.disabled = true;
      
      const wasDetecting = isDetecting;
      isDetecting = false;
      
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      const success = await startCamera();
      
      if (success && wasDetecting) {
        isDetecting = true;
        detectObjects();
        updateStatus('ready', '‚úÖ Kamera Diganti!', 'Deteksi berlanjut dengan kamera baru.');
      }
      
      btnSwitch.disabled = false;
    });
    
    btnClearLog.addEventListener('click', () => {
      clearLog();
    });
    
    thresholdSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      threshold = value / 100;
      thresholdValue.textContent = value;
    });
    
    // ============================================
    // CLEANUP
    // ============================================
    window.addEventListener('beforeunload', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      stopCamera();
    });
    
    // ============================================
    // START APPLICATION
    // ============================================
    init();
  </script>
</body>
</html>
